// ==UserScript==
// @name         LinkedIn Crawler
// @namespace    http://tampermonkey.net/
// @version      1.5
// @description  Crawls LinkedIn and collects data on all jobs.
// @match        *://*.linkedin.com/*
// @grant        GM_setClipboard
// @grant        GM_setValue
// @grant        GM_getValue
// @run-at       document-idle
// ==/UserScript==

(function () {
    "use strict";
    const LOCAL_STORAGE_KEY = 'tamper-monkey-linkedin-job-data';
    const LOCAL_DATA_DEFAULT = {
        jobData: ''
    }
    const STOP_FUNC_DEFAULT = {
        flag: false,
        resolve: undefined,
        firstRun: false,
        stoppedAt: 0
    }
    // Flags used to quit a crawl early.
    let stopFunc = { ...STOP_FUNC_DEFAULT, firstRun: true };
    // Flag for in progress crawl operation.
    let crawlerInProgress = false;

    const SCROLLABLE_JOB_LIST = '.scaffold-layout__list > div:first-of-type'
    const JOB_LIST_SELECTOR = SCROLLABLE_JOB_LIST + ' > ul';
    const JOB_ITEM_SELECTOR = JOB_LIST_SELECTOR + ' > li';
    const NEXT_PAGE_BUTTON_SELECTOR = '.jobs-search-pagination__button--next';
    const TITLE_SELECTOR = '.job-details-jobs-unified-top-card__job-title'
    const JOB_INFO_BUTTONS_SELECTOR = '.job-details-fit-level-preferences';
    const getClickableSelector = (jobId) => [
        `[data-occludable-job-id="${jobId}"] [data-job-id="${jobId}"]`,
        `[data-occludable-job-id="${jobId}"] .job-card-container--clickable`
    ]

    const JOB_DIVIDER_TEXT = '\n=-=-=-=-=\n';
    const MAX_JOB_PROCESS_ATTEMPTS = 10;
    const MAX_JOB_COPY_ATTEMPTS = 5;

    let jobData = GM_getValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT).jobData || '';
    let page = 0;
    let jobs_per_page = 0;

    let toastElement;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // .click() is stopped by LinkedIn security.
    const click = (element) => {
        element.dispatchEvent(
            new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
            })
        );
    }

    const scrollToBottom = (scrollList, { timeout = 5000, epsilon = 2 } = {}) => {
        return new Promise((resolve, reject) => {
            scrollList.scrollTo({
                top: scrollList.scrollHeight,
                behavior: 'smooth'
            });
            const start = performance.now();

            function atBottom() {
                return scrollList.scrollTop + scrollList.clientHeight >= scrollList.scrollHeight - epsilon;
            }

            function tick() {
                scrollList.scrollTo({
                    top: scrollList.scrollHeight,
                    behavior: 'smooth'
                });
                if (atBottom()) return resolve(true);
                if (performance.now() - start > timeout) return reject(new Error('Timed out waiting for bottom'));
                requestAnimationFrame(tick);
            }

            tick();
        });
    }

    // Raise a on-screen message (toast)
    const toast = (msg, ms = 2000) => {
        console.log('toast:', msg);
        toastElement?.remove();
        toastElement = document.createElement("div");
        toastElement.innerHTML = msg;
        Object.assign(toastElement.style, {
            position: "fixed",
            top: '200px',
            left: "50%",
            transform: "translate(-50%, -50%)",
            padding: "20px 24px",
            borderRadius: "8px",
            background: "rgba(0,0,0,0.85)",
            color: "white",
            fontSize: "36px",
            zIndex: 999999,
            maxWidth: "40vw",
            lineHeight: "1.3",
        });
        document.body.appendChild(toastElement);
        setTimeout(() => toastElement.remove(), ms);
    }

    const getjobDescription= () => {
        return (
            document.querySelector(".jobs-description__content #job-details") || // best target: actual description
            document.querySelector("#job-details") ||
            document.querySelector(".jobs-description__content") ||
            document.querySelector(".jobs-details__main-content")
        );
    }

    // Retrieve the text from the job description.
    const getJobText = (rootEl) => {
        // Clone so we can safely modify without affecting the page
        const el = rootEl.cloneNode(true);

        // Remove noisy / non-content elements
        const REMOVE_TAGS = ["script", "style", "svg", "img", "button", "nav", "footer", "noscript"];
        REMOVE_TAGS.forEach(tag => el.querySelectorAll(tag).forEach(n => n.remove()));

        el.querySelectorAll(
            '[aria-hidden="true"], .visually-hidden, .a11y-text, [role="presentation"]'
        ).forEach(n => n.remove());

        // Add bullets
        el.querySelectorAll("li").forEach(li => {
            if (!li.textContent.trim().startsWith("•")) li.prepend("• ");
        });

        // Convert <br> to newline
        el.querySelectorAll("br").forEach(br => br.replaceWith("\n"));

        // Add newlines after blocky elements
        const BLOCKS = ["p", "div", "section", "article", "h1", "h2", "h3", "ul", "ol", "li"];
        BLOCKS.forEach(tag => {
            el.querySelectorAll(tag).forEach(n => n.append("\n"));
        });

        const text = (el.innerText || el.textContent || "");
        return text
            .replace(/(\s*\n){3,}/g, "\n\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const getJobTitle = () => {
        const text = document.querySelector(TITLE_SELECTOR).querySelector('h1')?.textContent.trim();
        if(text){
            return `\nTITLE: ${text}\n`;
        }
        return '';
    }

    const getJobSalary = () => {
        const jobInfoButtons = document.querySelector(JOB_INFO_BUTTONS_SELECTOR).querySelectorAll('button');

        for(let button of jobInfoButtons){
            const strongElement = button?.closest(':has(strong)')?.querySelector('strong');
            const text = strongElement.innerText || strongElement.textContent || "";
            // Check if button has numbers (Only Salary button has numbers)
            if(/\d/g.test(text)){
                return `\nSalary: ${text}\n`;
            }
        }
        return '';
    }

    const cleanJobData = () => {
        jobData = jobData.replace(/(\s*\n){3,}/g, "\n\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const copyJobDataToClipboard = () => {
        try {
            cleanJobData();
            GM_setClipboard(jobData);
            toast("Copied job text to clipboard.");
        } catch (err) {
            console.error("GM_setClipboard failed:", err);
            alert("Clipboard copy failed.");
        }
    }

    const copyJob = () => {

        const getJobData = (resolve, attempt = 0) => {
            const description = getjobDescription();
            if (!description) {
                toast(`Could not find the job description: attempt ${attempt + 1}/${MAX_JOB_COPY_ATTEMPTS}`);
                if(attempt < MAX_JOB_COPY_ATTEMPTS){
                    setTimeout(() => getJobData(resolve, attempt + 1), 500 * (attempt + 1))
                } else {
                    toast('Failed to retrieve job data, skipping...');
                    resolve()
                }
                return;
            }
            const text = getJobText(description);
            const title = getJobTitle();
            const url = `\nURL: ${window.location.href}\n`;
            const salary = getJobSalary();
            jobData += JOB_DIVIDER_TEXT + title + url + salary + text;
            resolve();
        }

        return new Promise((resolve) => {
            getJobData(resolve);
        });
    }



    const jobCollector = async () => {
        crawlerInProgress = true;
        let jobList, jobListContainer, maxJobs, ScrollableContainer;

        // Returns elements needed for iterating through list of jobs.
        const getJobListElements = () => {
            jobListContainer = document.querySelector(JOB_LIST_SELECTOR);
            jobList = Array.from(document.querySelectorAll(JOB_ITEM_SELECTOR))
            jobs_per_page = jobList.length;
            maxJobs = jobs_per_page - 1;
        };

        // Moves to next page or terminates the crawl if finished.
        const next = async () => {
            GM_setValue(LOCAL_STORAGE_KEY, {
                jobData,
            });
            page += 1;
            const button = document.querySelector(NEXT_PAGE_BUTTON_SELECTOR);
            // Move to next page or finish crawl
            if(!button || button.disalbed){
                copyJobDataToClipboard();
                alert('Crawl Complete, press alt-2 to copy results to clipboard')
            } else {
                click(button)
                toast('Moving to next page...');
                await sleep(4000);
                stopFunc.stoppedAt = 0;
                processJob(0);
            }
        }

        const reattempt = async (iter, attempt, { job, jobId }) => {
            if(attempt > MAX_JOB_PROCESS_ATTEMPTS) {
                toast(`Unable to load Job #${iter + 1} on list, Skipping...`);
                processJob(iter + 1)
            } else {
                await sleep(500 * (attempt + 1));
                processJob(iter, attempt + 1)
            }
        }

        // Process an individual job before moving to next.
        async function processJob (iter = stopFunc.stoppedAt || 0, attempt = 0) {
            // If reset flag is set, stop operation.
            if(stopFunc.flag) {
                stopFunc.resolve(Math.max(iter - 1, 0));
                GM_setValue(LOCAL_STORAGE_KEY, {
                    jobData,
                });
                return;
            }

            getJobListElements();

            let job = jobList[iter];
            //Scroll List Element into view, then restart retreival process to dodge DOM rerenders.
            job.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
            await sleep(2000);
            getJobListElements();
            job = jobList[iter];
            const jobId = job.getAttribute('data-occludable-job-id')
            const clickableSelectors = getClickableSelector(jobId);
            const clickable = document.querySelector(clickableSelectors[0])
            || document.querySelector(clickableSelectors[1])
            //|| document.querySelector('.job-card-container--clickable')

            if(clickable) {
                const jobNo = page * jobs_per_page + iter + 1;
                toast(`Job: #${jobNo}`, 900);
                clickable.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                click(clickable);

                // Wait to avoid Code 429 before copying code
                await sleep(1500);
                await copyJob();

                // Crawl Next Job on List
                if(iter < maxJobs){
                    processJob(iter + 1)
                } else {
                    next();
                }
                // Handle issue with page load.
            } else {
                reattempt(iter, attempt, { job, jobId });
            }
        }

        ScrollableContainer = document.querySelector(SCROLLABLE_JOB_LIST);
        await scrollToBottom(ScrollableContainer);
        processJob();
    }

    const reset = (hard) => {
        return new Promise((resolve) => {
            if(hard){
                jobData = '';
            }
            GM_setValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT)
            if(stopFunc.firstRun){
                stopFunc = STOP_FUNC_DEFAULT;
                resolve();
            } else {
                // Flag for STOP
                stopFunc = {
                    flag: true,
                    resolve: (stoppedAt = 0) => {
                        stopFunc = { ...STOP_FUNC_DEFAULT, stoppedAt };
                        crawlerInProgress = false;
                        resolve();
                    },
                    firstRun: false,
                    stoppedAt: stopFunc.stoppedAt || 0
                }
                // Reset Manually if enough time has passed.
                setTimeout(() => {
                    if(stopFunc.flag) {
                        stopFunc.resolve();
                    }
                }, 20000)
            }
        });
    }

    const hotKeys = {
        '0': 'Help',
        '1': 'Start crawler from begining',
        '2': 'Copy job data to clipboard',
        '3': 'Resume a stopped crawl',
        '5': 'Stop a crawl',
    }

    const describeHotKeys = () => {
        let description = 'Short Cuts:<br />';
        let first = true;
        for(let key in hotKeys){
            if(first){
                first = false;
            }
            description += `${key}: ${hotKeys[key]}<br />`;
        }
        return description;
    }

    const handleKeyPress = async (event) => {
        const altKey = event.altKey;
        const key = event.key.toLowerCase();
        if (altKey){
            if(key === '1') {
                toast('Starting...');
                await reset(true);
                jobCollector();
            }
            if(key === '2'){
                toast(`Copying ${jobData.match(/=-=-=-=-=/g)?.length || 0} Jobs to Clipboard`);
                copyJobDataToClipboard()
            }
            if(key === '3'){
                if(crawlerInProgress){
                    toast('Crawler already in progress');
                }
                toast(`Resuming Crawl from Job: ${jobData.match(/=-=-=-=-=/g)?.length || 0}`);
                jobCollector();
            }
            if(key === '5'){
                toast('Stopping Crawl...');
                await reset();
                toast('Crawl Terminated')
            }
            if(key === '0'){
                toast(describeHotKeys(), 10000);
            }
        }
    }

    document.addEventListener(
        "keydown",
        handleKeyPress,
        false
    );
})();