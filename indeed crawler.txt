// ==UserScript==
// @name         Indeed Crawler
// @namespace    http://tampermonkey.net/
// @version      1.5
// @description  Crawls Indeed and collects data on all jobs.
// @match        *://*.indeed.com/*
// @grant        GM_setClipboard
// @grant        GM_setValue
// @grant        GM_getValue
// @run-at       document-idle
// ==/UserScript==

(function () {
    "use strict";
    const LOCAL_STORAGE_KEY = 'tamper-monkey-indeed-job-data';
    const LOCAL_DATA_DEFAULT = {
        inProgress: false,
        jobData: ''
    }
    const STOP_FUNC_DEFAULT = {
        flag: false,
        resolve: undefined,
        firstRun: false,
        stoppedAt: 0
    }
    // Flags used to quit a crawl early.
    let stopFunc = { ...STOP_FUNC_DEFAULT, firstRun: true };
    // Flag for in progress crawl operation.
    let crawlerInProgress = false;

    const JOB_ITEM_SELECTOR = '#mosaic-provider-jobcards > div:first-of-type > ul:first-of-type > li > div.result:not([aria-hidden="true"])';
    const JOB_ID_ELEMENT_SELECTOR = '.jobTitle > a'; // query from JOB_ITEM_SELECTOR
    const JOB_SALARY_SELECTOR = 'ul.metadataContainer > li.salary-snippet-container > div:first-of-type > div > span'; // query from JOB_ITEM_SELECTOR
    const CLICKABLE_SELECTOR = '.jcs-JobTitle > span';

    const JOB_DESCRIPTION_SELECTOR = 'div#jobDescriptionText';

    const NEXT_PAGE_BUTTON_SELECTOR = 'a[data-testid="pagination-page-next"]';

    const JOB_DIVIDER_TEXT = '\n=-=-=-=-=\n';
    const MAX_JOB_PROCESS_ATTEMPTS = 10;
    let localData = GM_getValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT)

    let jobData = localData.jobData || '';
    let inProgress = localData.inProgress || false;

    let toastElement;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // .click() is stopped by LinkedIn security.
    const click = (element) => {
        element.dispatchEvent(
            new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
            })
        );
    }

    // Raise a on-screen message (toast)
    const toast = (msg, ms = 2000) => {
        console.log('Toast:', msg);
        toastElement?.remove();
        toastElement = document.createElement("div");
        toastElement.textContent = msg;
        Object.assign(toastElement.style, {
            position: "fixed",
            top: '200px',
            left: "50%",
            transform: "translate(-50%, -50%)",
            padding: "20px 24px",
            borderRadius: "8px",
            background: "rgba(0,0,0,0.85)",
            color: "white",
            fontSize: "36px",
            zIndex: 999999,
            maxWidth: "40vw",
            lineHeight: "1.3",
        });
        document.body.appendChild(toastElement);
        setTimeout(() => toastElement.remove(), ms);
    }

    // Retrieve the text from the job description.
    const getJobText = (rootEl) => {
        // Clone so we can safely modify without affecting the page
        const el = rootEl.cloneNode(true);

        // Remove noisy / non-content elements
        const REMOVE_TAGS = ["script", "style", "svg", "img", "button", "nav", "footer", "noscript"];
        REMOVE_TAGS.forEach(tag => el.querySelectorAll(tag).forEach(n => n.remove()));

        el.querySelectorAll(
            '[aria-hidden="true"], .visually-hidden, .a11y-text, [role="presentation"]'
        ).forEach(n => n.remove());

        // Add bullets
        el.querySelectorAll("li").forEach(li => {
            if (!li.textContent.trim().startsWith("•")) li.prepend("• ");
        });

        // Convert <br> to newline
        el.querySelectorAll("br").forEach(br => br.replaceWith("\n"));

        // Add newlines after blocky elements
        const BLOCKS = ["p", "div", "section", "article", "h1", "h2", "h3", "ul", "ol", "li"];
        BLOCKS.forEach(tag => {
            el.querySelectorAll(tag).forEach(n => n.append("\n"));
        });

        const text = (el.innerText || el.textContent || "");
        return text
            .replace(/(\s*\n\s*){2,}/g, "\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const getJobTitle = (jobElement) => {
        const idElement = jobElement.querySelector(JOB_ID_ELEMENT_SELECTOR).id.replace('job_', '');

        const title = document.querySelector('#jobTitle-' + idElement)?.textContent.trim();
        if(title){
            return `\nTITLE: ${title}\n`;
        }
        return '';
    }

    const getJobSalary = (jobElement) => {
        const jobInfoButtons = jobElement.querySelector(JOB_SALARY_SELECTOR);
        const salary = jobInfoButtons?.innerText || jobInfoButtons?.textContent || "";
        return salary ? `\nSALARY: ${salary}\n`: ''
    }

    const cleanJobData = () => {
        jobData = jobData.replace(/(\s*\n\s*){3,}/g, "\n\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const copyJobDataToClipboard = () => {
        return new Promise((resolve) => {
            try {
                cleanJobData();
                GM_setClipboard(jobData);
                toast("Copied job text to clipboard.");
            } catch (err) {
                console.error("GM_setClipboard failed:", err);
                alert("Clipboard copy failed.");
            }
        })
    }

    const getJobDescription = () => {
        const maxAttempts = 10;
        return new Promise((resolve) => {

            const getDescriptionElement = (attempt = 0) => {
                const jobDescription = document.querySelector(JOB_DESCRIPTION_SELECTOR);
                if(!jobDescription){
                    if(attempt < maxAttempts){
                        setTimeout(() => getDescriptionElement(attempt + 1), 500);
                    } else {
                        alert("Could not find the job description.");
                        resolve();
                    }
                } else {
                    resolve(jobDescription);
                }
            }
            getDescriptionElement();
        })
    }

    const copyJob = async (jobElement) => {
        const jobDescription = await getJobDescription();
        if (!jobDescription) {
            alert("Could not find the job description.");
            return;
        }
        const text = getJobText(jobDescription);
        const title = getJobTitle(jobElement);
        const url = `\nURL: ${window.location.href}\n`;
        const salary = getJobSalary(jobElement);
        jobData += JOB_DIVIDER_TEXT + title + url + salary + '\n' + text;
    }



    const jobCollector = async () => {
        crawlerInProgress = true;
        let jobList, maxJobs;

        // Returns elements needed for iterating through list of jobs.
        const getJobListElements = () => {
            jobList = Array.from(document.querySelectorAll(JOB_ITEM_SELECTOR));
            maxJobs = jobList.length - 1;
        };

        // Moves to next page or terminates the crawl if finished.
        const next = () => {
            // Move to next page or finish crawl
            const button = document.querySelector(NEXT_PAGE_BUTTON_SELECTOR);
            if(!button){
                copyJobDataToClipboard();
                GM_setValue(LOCAL_STORAGE_KEY, {
                    inProgress: false,
                    jobData,
                });
                alert('Crawl Complete, press alt-2 to copy results to clipboard')
            } else {
                GM_setValue(LOCAL_STORAGE_KEY, {
                    inProgress: true,
                    jobData,
                });
                click(button);
                toast('Moving to next page...');
            }
        }

        // Process an individual job before moving to next.
        async function processJob (iter = stopFunc.stoppedAt, attempt = 0) {
            // If reset flag is set, stop operation.
            if(stopFunc.flag) {
                stopFunc.resolve(Math.max(iter - 1, 0));
                GM_setValue(LOCAL_STORAGE_KEY, {
                    inProgress: false,
                    jobData,
                });
                return;
            }

            getJobListElements();
            const job = jobList[iter];
            const clickable = job?.querySelector(CLICKABLE_SELECTOR);
            if(clickable) {
                toast(`Clicking #${iter + 1}`, 900);
                // Scroll currently viewed job into view on job list.
                clickable.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                // Scroll up a little.
                setTimeout(() => {
                    window.scrollBy({ top: -100, behavior: "smooth" });
                }, 100);
                click(clickable);

                // Wait to avoid Code 429 before copying code
                await sleep(1250);
                copyJob(job);

                // Crawl Next Job on List
                if(iter < maxJobs){
                    await sleep(1500);
                    processJob(iter + 1)
                } else {
                    next();
                }
                // Handle issue with page load.
            } else {
                if(attempt > MAX_JOB_PROCESS_ATTEMPTS) {
                    toast(`Unable to load Job #${iter + 1} on list, Skipping...`);
                    processJob(iter + 1)
                } else {
                    await sleep(500 + attempt * 500);
                    processJob(iter, attempt + 1)
                }
            }
        }
        processJob();
    }

    const reset = (hard) => {
        return new Promise((resolve) => {
            if(hard){
                jobData = '';
            }
            GM_setValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT)
            if(stopFunc.firstRun){
                stopFunc = STOP_FUNC_DEFAULT;
                resolve();
            } else {
                // Flag for STOP
                stopFunc = {
                    flag: true,
                    resolve: (stoppedAt = 0) => {
                        stopFunc = { ...STOP_FUNC_DEFAULT, stoppedAt };
                        crawlerInProgress = false;
                        resolve();
                    },
                    firstRun: false,
                    stoppedAt: stopFunc.stoppedAt || 0
                }
                // Reset Manually if enough time has passed.
                setTimeout(() => {
                    if(stopFunc.flag) {
                        stopFunc.resolve();
                    }
                }, 20000)
            }
        });
    }


    const handleKeyPress = async (event) => {
        const altKey = event.altKey;
        const key = event.key.toLowerCase();
        if (altKey){
            if(key === '1') {
                toast('Starting...');
                await reset(true);
                jobCollector();
            }
            if(key === '2'){
                toast(`Copying ${jobData.match(/=-=-=-=-=/g)?.length || 0} Jobs to Clipboard`);
                copyJobDataToClipboard()
            }
            if(key === '3'){
                toast(`Resuming Crawl from Job: ${jobData.match(/=-=-=-=-=/g)?.length || 0}`);
                jobCollector();
            }
            if(key === '5'){
                toast('Stopping Crawl...');
                await reset();
                toast('Crawl Terminated')
            }
            if(key === '0'){
                toast(describeHotKeys(), 10000);
            }
        }
    }

    document.addEventListener(
        "keydown",
        handleKeyPress,
        false
    );

    if(inProgress) {
        GM_setValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT)
        jobCollector();
    }
})();