// ==UserScript==
// @name         Ziprecruiter Crawler
// @namespace    http://tampermonkey.net/
// @version      1.5
// @description  Crawls Ziprecruiter and collects data on all jobs.
// @match        *://*.ziprecruiter.com/*
// @grant        GM_setClipboard
// @grant        GM_setValue
// @grant        GM_getValue
// @run-at       document-idle
// ==/UserScript==

(function () {
    "use strict";
    const LOCAL_STORAGE_KEY = 'tamper-monkey-ziprecruiter-job-data';
    const LOCAL_DATA_DEFAULT = {
        jobData: ''
    }
    const STOP_FUNC_DEFAULT = {
        flag: false,
        resolve: undefined,
        firstRun: false,
        stoppedAt: 0
    }
    // Flags used to quit a crawl early.
    let stopFunc = { ...STOP_FUNC_DEFAULT, firstRun: true };
    // Flag for in progress crawl operation.
    let crawlerInProgress = false;
    let startTime;
    const JOB_ITEM_SELECTOR = 'section.job_results_two_pane > div.job_result_two_pane_v2';
    const TITLE_SELECTOR = 'article:first-of-type > section:first-of-type > div:nth-of-type(2)'
    + ' > div:first-of-type > button:first-of-type > div:first-of-type > div:first-of-type > h2';
    const JOB_DESCRIPTION_SELECTOR = '.text-primary.whitespace-pre-line.wrap-anywhere'
    const JOB_TTL_AMT_SELECTOR = '#serp_content_skip > p';
    const ALREADY_APPLIED_BUTTON_SELECTOR = '[data-testid="job-details-scroll-container"] [aria-label="Applied"]'

    //article:first-of-type > section:first-of-type > div:nth-of-type(2)'
    //+ ' > div:first-of-type > div:first-of-type >
    const JOB_SALARY_SELECTOR = 'div.break-all > p';

    const NEXT_PAGE_BUTTON_SELECTOR = '[title="Next Page"]';

    const JOB_DIVIDER_TEXT = '\n=-=-=-=-=\n';
    const MAX_JOB_PROCESS_ATTEMPTS = 10;
    const ONE_SECOND = 1000;
    const ONE_MINUTE_IN_SECONDS = 60
    const ONE_HOUR = 3600000
    const REPLACE_IN_URL = [
        '&refine_by_location_type=&',
        '&refine_by_apply_type=&',
        '&refine_by_experience_level=&'
        ]

    let jobData = GM_getValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT).jobData || '';
    let page = 0;
    let jobs_per_page = 0;

    let toastElement;

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // .click() is stopped by LinkedIn security.
    const click = (element) => {
        element.dispatchEvent(
            new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
            })
        );
    }

    // Raise a on-screen message (toast)
    const toast = (msg, ms = 10000) => {
        console.log('Toast:', msg);
        toastElement?.remove();
        toastElement = document.createElement("div");
        toastElement.innerHTML = msg;
        Object.assign(toastElement.style, {
            position: "fixed",
            top: '200px',
            left: "50%",
            transform: "translate(-50%, -50%)",
            padding: "20px 24px",
            borderRadius: "8px",
            background: "rgba(0,0,0,0.85)",
            color: "white",
            fontSize: "36px",
            zIndex: 999999,
            maxWidth: "40vw",
            lineHeight: "1.3",
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            textAlign: 'center'
        });
        document.body.appendChild(toastElement);
        setTimeout(() => toastElement.remove(), ms);
    }

    // Retrieve the text from the job description.
    const getJobText = (rootEl) => {
        // Clone so we can safely modify without affecting the page
        const el = rootEl.cloneNode(true);

        // Remove noisy / non-content elements
        const REMOVE_TAGS = ["script", "style", "svg", "img", "button", "nav", "footer", "noscript"];
        REMOVE_TAGS.forEach(tag => el.querySelectorAll(tag).forEach(n => n.remove()));

        el.querySelectorAll(
            '[aria-hidden="true"], .visually-hidden, .a11y-text, [role="presentation"]'
        ).forEach(n => n.remove());

        // Add bullets
        el.querySelectorAll("li").forEach(li => {
            if (!li.textContent.trim().startsWith("•")) li.prepend("• ");
        });

        // Convert <br> to newline
        el.querySelectorAll("br").forEach(br => br.replaceWith("\n"));

        // Add newlines after blocky elements
        const BLOCKS = ["p", "div", "section", "article", "h1", "h2", "h3", "ul", "ol", "li"];
        BLOCKS.forEach(tag => {
            el.querySelectorAll(tag).forEach(n => n.append("\n"));
        });

        const text = (el.innerText || el.textContent || "");
        return text
            .replace(/(\s*\n){3,}/g, "\n\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const getJobTitle = (jobElement) => {
        const text = jobElement.querySelector(TITLE_SELECTOR)?.textContent.trim();
        if(text){
            return `\nTITLE: ${text}\n`;
        }
        return '';
    }

    const getJobSalary = (jobElement) => {
        const jobInfoButtons = jobElement.querySelector(JOB_SALARY_SELECTOR);
        const salary = jobInfoButtons?.innerText || jobInfoButtons?.textContent || "";
        return salary ? `\nSALARY: ${salary}\n`: ''
    }

    const getJobTtlAmt = () => {
        const jobTtlAmtSpan = document.querySelector(JOB_TTL_AMT_SELECTOR);
        return (jobTtlAmtSpan.innerText || jobTtlAmtSpan.textContent || jobTtlAmtSpan.innerHtml || "").replace(/\D/g, "")
    }

    const toastJobUpdate = (jobNo, skipped = 0) => {
        if (!startTime) {
            alert("Error: toastJobUpdate called with unset start time");
            return;
        }

        const pad2 = (n) => String(Math.floor(n)).padStart(2, "0");

        const timeInSeconds = parseFloat((performance.now() - startTime) / ONE_SECOND); // number
        const hours = Math.floor(timeInSeconds / ONE_HOUR);

        let remaining_time = timeInSeconds - hours * ONE_HOUR;
        const minutes = Math.floor(remaining_time / ONE_MINUTE_IN_SECONDS);
        const seconds = Math.floor(remaining_time % ONE_MINUTE_IN_SECONDS);

        // Always show mm:ss, and if hours exist show hh:mm:ss (with leading zeros)
        const timeStr = `${hours > 0 ? pad2(hours) + ':': ''}${pad2(minutes)}:${pad2(seconds)}`

        let jobTtlAmtText = getJobTtlAmt();
        jobTtlAmtText = jobTtlAmtText ? ` / ${jobTtlAmtText}`: '';

        const skippedJobsText = skipped ? `<br /> ${skipped} Skipped`: ''

        toast(`Job: ${jobNo}${jobTtlAmtText} <br/> ${timeStr}${skippedJobsText}`);
    };


    const cleanJobData = () => {
        jobData = jobData.replace(/(\s*\n){3,}/g, "\n\n")
            .replace(/[ \t]{2,}/g, " ")
            .trim();
    }

    const copyJobDataToClipboard = () => {
        try {
            cleanJobData();
            GM_setClipboard(jobData);
            toast("Copied job text to clipboard.");
        } catch (err) {
            console.error("GM_setClipboard failed:", err);
            alert("Clipboard copy failed.");
        }
    }

    const copyJob = (jobElement) => {
        const jobDescription = document.querySelector(JOB_DESCRIPTION_SELECTOR);
        if (!jobDescription) {
            alert("Could not find the job description. Scroll so it loads, then try again.");
            return;
        }
        const text = getJobText(jobDescription);
        const title = getJobTitle(jobElement);
        let url = `\nURL: ${window.location.href}\n`;
        // Get rid of unused fields in the URL so the URL is less than 255 characters long
        // (Excel sheet does not allow links larger than 255 characters)
        for(const stringToReplace of REPLACE_IN_URL){
            url = url.replace(stringToReplace, '');
        }
        const salary = getJobSalary(jobElement);
        jobData += JOB_DIVIDER_TEXT + title + url + salary + '\n' + text;
    }



    const jobCollector = async () => {
        startTime = performance.now();
        crawlerInProgress = true;
        let jobList, maxJobs;
        let jobsSkipped = 0;

        // Returns elements needed for iterating through list of jobs.
        const getJobListElements = () => {
            jobList = Array.from(document.querySelectorAll(JOB_ITEM_SELECTOR));
            jobs_per_page = jobList.length;
            maxJobs = jobs_per_page - 1;
        };

        // Moves to next page or terminates the crawl if finished.
        const next = async () => {
            GM_setValue(LOCAL_STORAGE_KEY, {
                jobData,
            });
            page += 1;
            // Move to next page or finish crawl
            const button = document.querySelector(NEXT_PAGE_BUTTON_SELECTOR);
            if(!button || button.disabled){
                copyJobDataToClipboard();
                alert('Crawl Complete, press alt-2 to copy results to clipboard')
            } else {
                click(button);
                toast('Moving to next page...');
                await sleep(4000);
                stopFunc.stoppedAt = 0;
                processJob(0);
            }
        }

        const reattempt = async (iter, attempt, { job }) => {
            if(attempt > MAX_JOB_PROCESS_ATTEMPTS) {
                toast(`Unable to load Job #${iter + 1} on list, Skipping...`);
                processJob(iter + 1)
            } else {
                await sleep(500 * (attempt + 1));
                processJob(iter, attempt + 1)
            }
        }

        // Process an individual job before moving to next.
        async function processJob (iter = stopFunc.stoppedAt, attempt = 0) {
            // If reset flag is set, stop operation.
            if(stopFunc.flag) {
                stopFunc.resolve(Math.max(iter - 1, 0));
                GM_setValue(LOCAL_STORAGE_KEY, {
                    jobData,
                });
                return;
            }

            getJobListElements();

            const job = jobList[iter];

            const clickableTitle = job?.querySelector(TITLE_SELECTOR);
            if(clickableTitle) {
                const jobNo = page * jobs_per_page + iter + 1;
                toastJobUpdate(jobNo, jobsSkipped);
                clickableTitle.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
                click(clickableTitle);

                // Wait to avoid Code 429 before copying code
                await sleep(1000);

                // Only copy job data if job has not already been applied to
                if(!document.querySelector(ALREADY_APPLIED_BUTTON_SELECTOR)){
                    copyJob(job);
                } else {
                    jobsSkipped++;
                    toast(`Skipping job: ${iter + 1}`);
                }

                // Crawl Next Job on List
                if(iter < maxJobs){
                    await sleep(2000);
                    processJob(iter + 1)
                } else {
                    next();
                }
                // Handle issue with page load.
            } else {
                reattempt(iter, attempt, { job });
            }
        }
        processJob();
    }

    const reset = (hard) => {
        return new Promise((resolve) => {
            if(hard){
                jobData = '';
            }
            GM_setValue(LOCAL_STORAGE_KEY, LOCAL_DATA_DEFAULT)
            if(stopFunc.firstRun){
                stopFunc = STOP_FUNC_DEFAULT;
                resolve();
            } else {
                // Flag for STOP
                stopFunc = {
                    flag: true,
                    resolve: (stoppedAt = 0) => {
                        stopFunc = { ...STOP_FUNC_DEFAULT, stoppedAt };
                        crawlerInProgress = false;
                        resolve();
                    },
                    firstRun: false,
                    stoppedAt: stopFunc.stoppedAt || 0
                }
                // Reset Manually if enough time has passed.
                setTimeout(() => {
                    if(stopFunc.flag) {
                        stopFunc.resolve();
                    }
                }, 20000)
            }
        });
    }

    const hotKeys = {
        '0': 'Help',
        '1': 'Start crawler from begining',
        '2': 'Copy job data to clipboard',
        '3': 'Resume a stopped crawl',
        '5': 'Stop a crawl',
    }

    const describeHotKeys = () => {
        let description = 'Short Cuts:<br />';
        let first = true;
        for(let key in hotKeys){
            if(first){
                first = false;
            }
            description += `${key}: ${hotKeys[key]}<br />`;
        }
        return description;
    }

    const handleKeyPress = async (event) => {
        const altKey = event.altKey;
        const key = event.key.toLowerCase();
        if (altKey){
            if(key === '1') {
                toast('Starting...');
                await reset(true);
                jobCollector();
            }
            if(key === '2'){
                toast(`Copying ${jobData.match(/=-=-=-=-=/g)?.length || 0} Jobs to Clipboard`);
                copyJobDataToClipboard()
            }
            if(key === '3'){
                toast(`Resuming Crawl from Job: ${jobData.match(/=-=-=-=-=/g)?.length || 0}`);
                jobCollector();
            }
            if(key === '5'){
                toast('Stopping Crawl...');
                await reset();
                toast('Crawl Terminated')
            }
            if(key === '0'){
                toast(describeHotKeys(), 10000);
            }
        }
    }

    document.addEventListener(
        "keydown",
        handleKeyPress,
        false
    );
})();